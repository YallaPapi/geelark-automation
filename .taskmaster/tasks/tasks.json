{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "Project skeleton, configuration, and input/output handling",
        "description": "Set up the Python project, config management, and basic CLI to load inputs (photos, bios, follow list, proxies, API keys) and write CSV output for created accounts.",
        "details": "Implementation details:\n- Use Python 3.11+ with a simple, single-package structure (e.g., `geelark_ig_bot/`).\n- Create `config.py` to load configuration from a `.env` file (using `python-dotenv`) or a `config.yaml` file (using `pyyaml`). Keys: DAISY_SMS_KEY, TWO_CAPTCHA_KEY, ANTHROPIC_KEY, PROXY_ROTATE_URL, GEELARK_DEVICE_ID or connection params, paths for PHOTOS_DIR, BIOS_FILE, FOLLOW_FILE, OUTPUT_CSV.\n- Implement a small `models.py` with dataclasses such as `AccountProfile(photo_path, bio, follow_targets)` and `RunContext(proxy_url, device_id, session_id, logs_path)`.\n- Implement `io_inputs.py`:\n  - Load all image paths from the photos folder (validate file extensions and existence).\n  - Load bios from a text file, one bio per non-empty line.\n  - Load accounts-to-follow from a text file, one username per non-empty line.\n- Implement `io_outputs.py` with function `append_created_account(csv_path, username, password, phone, status, extra=None)` that appends a row; ensure the CSV is created with a header if missing.\n- Implement `main.py` with a CLI (using `argparse`) that supports parameters like `--accounts N`, `--device-id`, `--start-index`, `--output-csv`.\n- Add logging (built-in `logging` module) with INFO for high-level steps and DEBUG for low-level details; log to both console and a rotating file handler.\n- Ensure paths and config values are validated at startup, with clear error messages and non-zero exit codes on failure.\n- Keep architecture minimal: a main loop that calls a `create_single_account(profile: AccountProfile)` function implemented in later tasks.\n\nPseudo-code sketch:\n```python\n# main.py\nfrom config import load_config\nfrom io_inputs import load_photos, load_bios, load_follow_targets\nfrom io_outputs import append_created_account\nfrom workflow import create_single_account\n\nif __name__ == \"__main__\":\n    cfg = load_config()\n    photos = load_photos(cfg.PHOTOS_DIR)\n    bios = load_bios(cfg.BIOS_FILE)\n    follows = load_follow_targets(cfg.FOLLOW_FILE)\n\n    for i in range(cfg.NUM_ACCOUNTS):\n        profile = build_profile(photos, bios, follows, i)\n        result = create_single_account(profile, cfg)\n        append_created_account(\n            cfg.OUTPUT_CSV,\n            result.username,\n            result.password,\n            result.phone,\n            result.status,\n        )\n```",
        "testStrategy": "- Unit test config loading with missing/invalid keys.\n- Unit test input loaders with temporary directories and sample files.\n- Unit test CSV writer: create temp file, append multiple rows, verify header and data.\n- Run a dry-run mode (no device interaction) that uses mock `create_single_account` to verify CLI, logging, and CSV pipeline behave correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Geelark device control abstraction (RPA/ADB/API)",
        "description": "Research and implement a minimal Python abstraction to control Geelark cloud phones (screenshot, tap, type, scroll) using the most reliable available method (RPA, ADB, or API).",
        "details": "Implementation details:\n- Investigate GeeLark’s RPA feature and any documented APIs from their dashboard/help center.[1]\n- Decide on a practical option:\n  - **Option A (preferred, if accessible):** Use GeeLark RPA/Custom tasks via HTTP or WebSocket if they expose an API to trigger actions on a running device (tap, input text, wait), or via a local bridge component.\n  - **Option B:** Connect via ADB over TCP to the cloud phone (if GeeLark exposes an ADB endpoint per phone). Use `adbutils` or `pure-python-adb` for screenshots and input events.\n  - **Option C:** If GeeLark has an official REST API to interact with cloud phones, wrap the relevant endpoints.\n- Define a Python interface `GeelarkDeviceController` in `geelark_device.py` with methods:\n  - `screenshot() -> bytes` (PNG/JPEG data)\n  - `tap(x: int, y: int)`\n  - `type_text(text: str)`\n  - `scroll(direction: Literal[\"up\",\"down\",\"left\",\"right\"], amount: int=500)`\n  - `back()` to press back button\n  - `home()` to go home\n  - `wait(seconds: float)` for simple delays.\n- Implement at least one concrete subclass, e.g., `AdbGeelarkDeviceController` or `RpaGeelarkDeviceController`, depending on what is feasible with GeeLark.\n- Include a simple device discovery/attachment function: `connect_device(device_id_or_host) -> GeelarkDeviceController`.\n- Ensure screenshot capturing is performant (e.g., ADB `exec-out screencap -p`), and images are in a format accepted by Claude Vision.\n\nExample using ADB-style pseudo-code:\n```python\nclass AdbGeelarkDeviceController(GeelarkDeviceController):\n    def __init__(self, serial: str):\n        self.adb = adbutils.AdbDevice(serial=serial)\n\n    def screenshot(self) -> bytes:\n        return self.adb.screencap()\n\n    def tap(self, x, y):\n        self.adb.shell(f\"input tap {x} {y}\")\n\n    def type_text(self, text):\n        safe = text.replace(\" \", \"%s\")\n        self.adb.shell(f\"input text '{safe}'\")\n\n    def scroll(self, direction, amount=500):\n        if direction == \"up\":\n            self.adb.shell(f\"input swipe 500 1000 500 {1000-amount}\")\n        # etc.\n```",
        "testStrategy": "- If ADB is used, test against a local Android emulator: verify that screenshot bytes are non-empty and tapping/types produce visible effects.\n- If GeeLark RPA/API is used, integration test on a disposable cloud phone: tap a known coordinate (e.g., Settings icon) and verify manually.\n- Add a `--test-device` CLI option that runs a quick health-check: take screenshot, tap a test area, log success/failure.\n- Use mocks in unit tests to assert high-level code calls `tap`, `type_text`, etc., with expected parameters.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Claude Vision screen understanding client",
        "description": "Implement a Python client that sends device screenshots and the current context to Claude Vision, parses its response into actionable steps with coordinates and text.",
        "details": "Implementation details:\n- Use Anthropic’s Python SDK or plain HTTP with API key from config.\n- Define a prompt template that instructs Claude Vision explicitly:\n  - Provide **screen description**.\n  - Provide **next action** in a strict JSON format with fields like `{\"action\": \"tap\"|\"type\"|\"scroll\"|\"done\"|\"wait\",\"coordinates\": {\"x\": int, \"y\": int},\"text\": \"...\", \"reason\": \"...\"}`.\n  - Ask it to always respond with a single JSON object and no extra text.\n  - Instruct it that the goal is to create and fully set up an Instagram account according to the step list (birthday, phone, SMS, username, password, skip optional, photo, bio, creator, follow accounts).\n- Implement `claude_vision.py` with:\n  - `class ClaudeVisionClient:`\n    - `propose_action(image_bytes: bytes, state: dict) -> dict` where `state` includes progress markers (e.g., `has_entered_birthday`, `has_verified_phone`).\n- Implement robust JSON parsing:\n  - Strip any non-JSON prefix/suffix if Claude accidentally adds text.\n  - Validate that required keys exist; if not, log error and request again with a clarifying system message.\n- Include rate limiting/backoff and simple retry for network errors or malformed responses.\n- Maintain a small `state` object that encodes goal progress to share with Claude in the system/user message so it can choose the next step more reliably.\n\nPseudo-code:\n```python\nSYSTEM_PROMPT = \"\"\"You are controlling an Android phone to create a new Instagram account...\"\"\"\n\ndef propose_action(self, img, state):\n    msg = self._build_message(state)\n    resp = self.client.messages.create(\n        model=\"claude-3.5-sonnet\",  # or latest vision-capable model\n        max_tokens=300,\n        temperature=0.1,\n        messages=[\n          {\"role\": \"system\", \"content\": SYSTEM_PROMPT},\n          {\"role\": \"user\", \"content\": [\n              {\"type\": \"image\", \"source\": {\"type\": \"base64\", \"media_type\": \"image/png\", \"data\": base64.b64encode(img).decode()}},\n              {\"type\": \"text\", \"text\": msg},\n          ]},\n        ],\n    )\n    json_str = extract_json(resp)\n    return json.loads(json_str)\n```",
        "testStrategy": "- Unit test prompt-building and JSON parsing with canned Claude-like responses.\n- Add an offline mode that uses a fake vision client returning predetermined actions for known test screenshots to validate the loop without spending API credits.\n- Log each request/response pair to a file (with redaction of secrets) and manually inspect a few runs to ensure action JSON is consistent.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "DaisySMS integration for phone number and SMS code retrieval",
        "description": "Implement integration with DaisySMS to rent phone numbers and poll for Instagram verification SMS codes.",
        "details": "Implementation details:\n- Review DaisySMS API docs to identify endpoints for:\n  - Requesting a number for a specific service/country.\n  - Checking SMS status and retrieving the code.\n  - Canceling/finishing an activation.\n- Implement `daisysms_client.py` with:\n  - `request_number(service=\"instagram\", country=None) -> Activation` where `Activation` holds `id`, `phone_number`.\n  - `wait_for_sms(activation_id, timeout=300, poll_interval=5) -> str` returning the numeric code.\n  - `cancel_activation(activation_id)` and `finish_activation(activation_id)`.\n- Handle common failure cases: no numbers, timeout waiting for SMS, banned/invalid numbers.\n- Mask phone number in logs for privacy.\n- Provide helper to format phone for entering on the device (e.g., strip `+` if needed, or let Claude decide how to input it given the screenshot).\n\nPseudo-code sketch:\n```python\nclass DaisySmsClient:\n    def request_number(self):\n        # call API, parse JSON\n        return Activation(id=act_id, phone=phone)\n\n    def wait_for_sms(self, act_id, timeout=300):\n        # loop: GET status, parse text, extract 6-digit code via regex\n```",
        "testStrategy": "- Unit test JSON parsing with sample DaisySMS responses.\n- Use a mock HTTP server (e.g., `responses` or `httpretty`) for DaisySMS endpoints to validate retry and timeout behavior.\n- In a staging run, manually request a number and send a test SMS from another phone to verify code extraction logic.\n- Simulate failure modes (no number, timeout, malformed SMS) and confirm the calling workflow handles them gracefully (marks account as failed, logs reason, releases activation).",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "2Captcha integration for solving Instagram captchas",
        "description": "Integrate with 2Captcha to submit Instagram captchas (image or possibly hCaptcha/ReCaptcha) and retrieve solutions when they appear during signup.",
        "details": "Implementation details:\n- Check 2Captcha docs for supported captcha types on Instagram flows (likely image captcha or hCaptcha/ReCaptcha). Implement at least generic image captcha support; leave hooks for sitekey-based captchas if needed.\n- Implement `twocaptcha_client.py` with:\n  - `submit_image_captcha(image_bytes) -> captcha_id`.\n  - `wait_for_solution(captcha_id, timeout=180, poll_interval=5) -> str`.\n- Integrate with the main flow via a simple contract: when Claude identifies a captcha on the screen and indicates an `action: \"captcha\"` (we can define this), capture a high-resolution screenshot and crop if necessary:\n  - Either ask Claude to provide bounding box coordinates, then crop the relevant region before sending to 2Captcha.\n- After receiving the solution string, pass it back to the device using `type_text` or `tap`/`type` sequences as directed by Claude.\n- Implement error handling: if 2Captcha returns an error or times out, mark run as failed and log details.\n\nPseudo-code:\n```python\nclass TwoCaptchaClient:\n    def submit_image_captcha(self, img):\n        # POST multipart/form-data to 2Captcha\n\n    def wait_for_solution(self, cap_id, timeout):\n        # poll /res.php until status=1\n```",
        "testStrategy": "- Unit test polling and response parsing using mocked 2Captcha HTTP endpoints.\n- Manual integration test with a known captcha image to confirm that 2Captcha returns the expected text.\n- Simulate failures such as `ERROR_CAPTCHA_UNSOLVABLE` and ensure workflow either retries with a new captcha or aborts with a clear status.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Mobile proxy rotation and network setup",
        "description": "Implement proxy rotation via a mobile proxy rotation URL before each new account and ensure all external calls from the device go through the rotated IP.",
        "details": "Implementation details:\n- Use the provided `PROXY_ROTATE_URL` config: before starting each new account creation, send a simple HTTP GET to this URL and wait a short delay (e.g., 5–10 seconds) for IP to change.\n- If GeeLark supports per-device proxy assignment, ensure the cloud phone is configured to use the mobile proxy; otherwise, rely on proxy at network edge.\n- Implement `proxy.py` with:\n  - `rotate_proxy() -> bool` which returns True on HTTP 2xx, False otherwise.\n- Add logging to record rotation attempts and results.\n- Optionally verify IP change using a cheap `https://api.ipify.org` style service via the device’s browser or host network (config-driven; disabled by default to avoid extra calls).\n- Integrate into `create_single_account` workflow: call `rotate_proxy()` once at the very beginning of each account run.\n\nPseudo-code:\n```python\ndef rotate_proxy(url, timeout=10):\n    try:\n        r = requests.get(url, timeout=timeout)\n        r.raise_for_status()\n        logger.info(\"Proxy rotated\")\n        time.sleep(8)\n        return True\n    except Exception as e:\n        logger.error(f\"Proxy rotation failed: {e}\")\n        return False\n```",
        "testStrategy": "- Unit test `rotate_proxy` with mocked HTTP responses (success, timeout, non-200).\n- In staging, call rotation multiple times and verify IP change manually using an external IP-check service.\n- Add a debug flag to log detected IPs (host-level) before and after rotation for manual verification.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Core action loop: screenshot → Claude → device actions",
        "description": "Implement the main control loop that repeatedly screenshots the Geelark device, asks Claude Vision what to do, executes the returned action (tap/type/scroll), and tracks progress toward account creation.",
        "details": "Implementation details:\n- Implement `workflow.py` with a function `run_screen_loop(device: GeelarkDeviceController, vision: ClaudeVisionClient, state: dict, max_steps=200) -> state`.\n- Loop behavior:\n  - For each step:\n    - Take screenshot via `device.screenshot()`.\n    - Call `vision.propose_action(image_bytes, state)`.\n    - Parse action JSON and execute:\n      - `action == \"tap\"`: call `device.tap(x, y)`.\n      - `action == \"type\"`: call `device.type_text(text)`.\n      - `action == \"scroll\"`: call `device.scroll(direction, amount)`.\n      - `action == \"wait\"`: call `device.wait(seconds)`.\n      - `action == \"back\"`/`\"home\"`: call corresponding methods.\n      - `action == \"done\"`: break loop and return.\n      - `action == \"captcha\"`: delegate to 2Captcha handler (Task 15) then feed solution back.\n    - Update `state` with any progress hints returned (e.g., `state[\"phase\"] = resp[\"phase\"]`).\n    - Add random small delays (0.5–1.5 s) to mimic human interaction and let UI update.\n- Implement safety guards:\n  - If `max_steps` reached without `done`, mark run as failed.\n  - Detect repeated identical actions (same tap coordinates for many steps) and break to avoid loops.\n- Ensure the state encodes key information for later steps (e.g., whether phone number has been used, SMS verified, username set, account switched to creator, followed 20 accounts).\n\nPseudo-code:\n```python\ndef run_screen_loop(device, vision, state, max_steps=200):\n    for i in range(max_steps):\n        img = device.screenshot()\n        action = vision.propose_action(img, state)\n        if action[\"action\"] == \"done\":\n            state[\"status\"] = \"done\"\n            break\n        execute_action(device, action, state)\n    return state\n```",
        "testStrategy": "- Implement unit tests for `execute_action` using a mock `GeelarkDeviceController` to verify correct calls for each action type.\n- Use an offline fake-vision client (from Task 13 tests) returning a deterministic series of actions to validate that the loop terminates correctly and state progresses.\n- On a test device with Instagram already on a simple form screen, run a short loop and confirm taps and typing correspond roughly to what Claude suggests (manual spot check using logs and video capture).",
        "priority": "high",
        "dependencies": [
          12,
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Account setup orchestration and Instagram-specific flow",
        "description": "Orchestrate a full Instagram account setup run, coordinating proxy rotation, device control, Claude-driven steps, DaisySMS phone/SMS handling, captchas, and the business logic for username/password, bio, photo, creator switch, and following accounts.",
        "details": "Implementation details:\n- Implement `create_single_account(profile: AccountProfile, cfg) -> AccountResult` in `workflow.py`.\n- High-level sequence:\n  1. Rotate proxy using Task 16.\n  2. Connect to Geelark device (Task 12) and ensure Instagram app is launched (via explicit launch intent or by tapping icon; you can teach Claude to tap the Instagram icon from home screen as part of loop).\n  3. Initialize `state` with:\n     - `target_bio`, `target_photo_path`, `follow_targets`.\n     - Flags: `birthday_entered`, `phone_requested`, `sms_verified`, `username_set`, `password_set`, `creator_switched`, `followed_count`.\n  4. Request DaisySMS number when the flow reaches phone entry stage:\n     - Either pre-request the number before starting, or better, when `state` indicates phone will be needed (e.g., when Claude says \"now enter phone number\").\n     - Store number and activation id in `state`.\n  5. Run `run_screen_loop` until `state[\"status\"] == \"done\"` or error.\n  6. In the loop integration, insert hooks based on `state`:\n     - When a screen expects the phone number, programmatically supply the DaisySMS number (you may give Claude the number in the context so it types it itself).\n     - After submitting phone, start a background `wait_for_sms` and when code is received, provide it to Claude in the next prompt so it can type it.\n     - For username/password, either auto-generate values in Python (e.g., random letters+digits) and provide them to Claude, or let Claude propose them but ensure Python records them in `state` so they can be output to CSV.\n  7. Ensure optional steps (such as contacts, notifications, etc.) are skipped—rely on Claude’s screen understanding but mention this explicitly in the prompt.\n  8. After reaching home feed, direct Claude (via state goal) to:\n     - Add profile photo from gallery: upload `target_photo_path` to the device or ensure the device already has a set of photos (outside of script scope) and instruct Claude accordingly.\n     - Add bio using `target_bio`.\n     - Switch to Creator account via settings (state flag `creator_switched=True` when done).\n     - Follow ~20 accounts from `follow_targets` list (give the list or next target to Claude in context, track `followed_count`).\n- Implement `AccountResult(username, password, phone, status, error_message=None)` dataclass.\n- On any unrecoverable error (DaisySMS/2Captcha failure, loop timeout, device disconnection), set `status=\"failed\"` and include `error_message`.\n",
        "testStrategy": "- Unit test orchestration logic with mocks for DaisySMS, 2Captcha, device controller, and Claude client to ensure correct call ordering and state changes.\n- Implement a dry-run mode that skips actual external calls and produces synthetic `AccountResult` to verify CSV output and control flow.\n- Run an end-to-end test on a single GeeLark device with manual observation, logging all key decisions; verify that a full account is created and appears in Instagram.\n- After a successful single-account run, test a small batch (e.g., 3 accounts) in series to validate that proxy rotation and resource cleanup between runs behave correctly.",
        "priority": "high",
        "dependencies": [
          12,
          13,
          14,
          15,
          16,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Profile data assignment and username/password generation",
        "description": "Implement logic to map input photos, bios, and follow lists to each new account and deterministically generate secure usernames and passwords.",
        "details": "Implementation details:\n- Implement `profiles.py` with:\n  - `build_profile(photos, bios, follows, index) -> AccountProfile` using round-robin or randomized selection.\n  - `generate_username(index, base=None) -> str` using a configurable pattern (e.g., random adjectives+noun+digits) and allowed Instagram constraints.\n  - `generate_password() -> str` with 12–16 chars including letters, digits, and symbols.\n- Ensure that for each account run, `AccountProfile` includes:\n  - `photo_path`: may be None if fewer photos than accounts; handle gracefully (skip photo step).\n  - `bio`: may be randomly chosen or selected sequentially.\n  - `follow_targets`: either the full list or a subset of ~20 selected per account.\n- Pass generated username and password into `state` to be shared with Claude so it types them when appropriate.\n- Avoid reusing the same username; if Instagram rejects a username, have Claude propose alternatives but keep track in state and update `AccountResult` accordingly.\n\nPseudo-code:\n```python\n@dataclass\nclass AccountProfile:\n    username: str\n    password: str\n    photo_path: Optional[str]\n    bio: Optional[str]\n    follow_targets: list[str]\n```",
        "testStrategy": "- Unit test profile building to ensure fair rotation of bios/photos and correct slicing of follow targets (~20 per account).\n- Unit test username/password generation for uniqueness and complexity constraints.\n- Use a mock Claude client to simulate username rejection; verify that state and `AccountResult` update to the new accepted username.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Logging, error handling, and basic scaling for multiple accounts",
        "description": "Harden the script with structured logging, error handling, cleanup between runs, and simple sequential multi-account execution.",
        "details": "Implementation details:\n- Extend logging from Task 11:\n  - Include per-account correlation ID in all logs.\n  - Log key milestones (proxy rotated, number acquired, SMS received, captcha solved, account created, failures).\n- Implement a central exception handler in `main.py` that catches unexpected errors per account, records a failed `AccountResult`, and continues to the next account instead of crashing the whole batch.\n- Add cleanup hooks:\n  - Release DaisySMS activations on error.\n  - Optionally reset Instagram app state between runs (e.g., clear data or log out via Claude instructions at end of run).\n- For scaling:\n  - Keep initial implementation strictly sequential (one account after another) to minimize complexity.\n  - Design the code to allow future parallelization (e.g., by making `create_single_account` stateless other than its arguments and return value), but do not add concurrency yet.\n- Expose a few runtime knobs via CLI/config: `MAX_STEPS`, `SMS_TIMEOUT`, `CAPTCHA_TIMEOUT`, `RETRY_LIMIT`.\n",
        "testStrategy": "- Simulate multiple account runs with mocks where some accounts succeed and others fail; verify that all results are written to CSV and script exits cleanly.\n- Inject failures (e.g., raise exceptions from DaisySMS/2Captcha/Claude clients) and confirm they are caught and logged and do not stop subsequent accounts.\n- Manual multi-account test (2–3 accounts) to verify logs are readable and correlated with account IDs.",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-10T03:59:28.494Z",
      "updated": "2025-12-10T04:21:12.826Z",
      "description": "Tasks for master context"
    }
  },
  "posting": {
    "tasks": [
      {
        "id": "105",
        "title": "Implement Connectivity & Startup Checks",
        "description": "Add validation for adb installation, device attachment, and Appium reachability in grapheneos_device_manager.py before controlling TikTok.",
        "details": "In grapheneos_device_manager.py, implement methods: check_adb_installed() using subprocess.run('adb version'), check_devices_attached() parsing 'adb devices' output for non-emulator devices, check_appium_status(appium_url) via requests.get(url + '/status'). Raise custom exceptions with clear messages like 'ADB not found in PATH'. Centralize in device_connection.py if separate. Call these sequentially at tiktok_poster.py startup when --device grapheneos.",
        "testStrategy": "Unit test each check method with mocked subprocess.run and requests.get responses. Integration test: run script with no adb, no device, wrong appium_url and verify early aborts with correct error messages.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:09:07.404Z"
      },
      {
        "id": "106",
        "title": "Normalize CLI Arguments in tiktok_poster.py",
        "description": "Update argument parser to accept positional phone_name, video_path, caption and new flags, with backwards compatibility for legacy flags.",
        "details": "Use argparse: add positional arguments phone_name, video_path, caption. Flags: --device (choices=['geelark','grapheneos']), --appium-url, --ai-only, --rules-only, --hybrid, --no-humanize, --max-steps (int). For legacy --account->phone_name, --video->video_path, --caption->caption, --mode->map to ai-only/rules-only/hybrid with warnings via argparse deprecation. Print friendly usage on legacy mismatch.",
        "testStrategy": "Test all valid CLI combinations via subprocess.run(tiktok_poster.py, args). Verify legacy flags map correctly with warnings logged. Test invalid args trigger usage help.",
        "priority": "high",
        "dependencies": [
          "105"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:10:14.838Z"
      },
      {
        "id": "107",
        "title": "Document Geelark TikTok Reference Flow",
        "description": "Extract and document working Geelark happy path from existing tiktok_poster.py, tiktok_action_engine.py, tiktok_screen_detector.py into markdown files.",
        "details": "Analyze code: trace Geelark (--device geelark) flow from HOME_FEED -> CREATE_MENU -> GALLERY_PICKER -> VIDEO_EDITOR -> CAPTION_SCREEN -> POST_SUCCESS. Note screen detection rules and action functions used per step. Write .taskmaster/docs/geelark_tiktok_flow.md with numbered steps, code references. Create grapheneos_vs_geelark_tiktok_diffs.md comparing element IDs/xpaths from error logs.",
        "testStrategy": "Manual verification: run Geelark flow, confirm documented steps match observed behavior. No code changes needed.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:12:11.992Z"
      },
      {
        "id": "108",
        "title": "Fix GrapheneOS Screen Detection Rules",
        "description": "Update tiktok_screen_detector.py with GrapheneOS-specific rules for CREATE_MENU, VIDEO_EDITOR, GALLERY_PICKER prioritizing Graphene IDs/texts.",
        "details": "In _detect_create_menu(): check Graphene texts 'Add sound', durations '10m','60s','15s', PHOTO/TEXT tabs, gallery thumbs (IDs r3r/ymg). _detect_video_editor(): require 'Next' button, exclude PHOTO/TEXT tabs. Use error_logs/ and flow_analysis/ for IDs. Add device-specific rule priority: Graphene > Geelark. Keep Geelark intact via if device=='geelark'.",
        "testStrategy": "Mock driver.get_page_source() with GrapheneOS log snippets, assert correct screen detected. Test priority: CREATE_MENU over VIDEO_EDITOR when ambiguous.",
        "priority": "high",
        "dependencies": [
          "107"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:13:09.702Z"
      },
      {
        "id": "109",
        "title": "Align GrapheneOS Action Handlers",
        "description": "Implement GrapheneOS branches in tiktok_action_engine.py for all screens using correct element IDs/xpaths instead of coordinates.",
        "details": "For each screen (HOME_FEED, CREATE_MENU, GALLERY_PICKER, VIDEO_EDITOR, CAPTION_SCREEN, POST_SUCCESS): if device=='grapheneos', use Graphene-specific selectors from logs (e.g. gallery thumb 'r3r', Next button text/ID). Fallback to Geelark. Replace coord taps with driver.find_element().click(). Ensure flow: home->+->gallery->select->next->caption->post->success.",
        "testStrategy": "Mock Appium driver, test each handler returns correct actions for GrapheneOS. Integration: run full flow on Graphene device, verify no coord taps logged.",
        "priority": "high",
        "dependencies": [
          "108"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:14:46.767Z"
      },
      {
        "id": "110",
        "title": "Centralize Humanization Primitives",
        "description": "Create humanization.py with tap_with_jitter, human_scroll_vertical, human_sleep primitives using Appium W3C actions.",
        "details": "def tap_with_jitter(driver, element=None, center=None, profile, rng): compute center, offset = rng.uniform(profile.tap_jitter_min_px, profile.tap_jitter_max_px), use driver.execute_script('mobile: touchAction', actions=[{'action':'tap', 'x':cx+dx, 'y':cy+dy}]). Similar for human_scroll_vertical (percent-based start/end Y, duration rng), human_sleep(base=None, jitter from profile). Platform-agnostic.",
        "testStrategy": "Unit tests: mock driver.execute_script, assert action params within jitter bounds. Verify RNG reproducibility.",
        "priority": "medium",
        "dependencies": [
          "109"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:16:39.640Z"
      },
      {
        "id": "111",
        "title": "Implement Account-Seeded BehaviorProfile",
        "description": "Add BehaviorProfile dataclass, base_seed storage in random_profiles.json, session_seed derivation, and build_behavior_profile.",
        "details": "from dataclasses import dataclass; @dataclass class BehaviorProfile: tap_jitter_min_px: float, etc. def get_or_create_base_seed(device, phone_name): hash_key=f'{device}::{phone_name}::tiktok', load/store json, base_seed=hash(hash_key)%(2**31). session_seed=base_seed ^ int(time.time()/21600). def build_behavior_profile(base_seed): rng=random.Random(base_seed), profile=BehaviorProfile(rng.uniform(2,8), ... ) using safe ranges from commits.",
        "testStrategy": "Test same (device,account) yields same base_seed/profile across runs. Different accounts differ. Session changes every 6h.",
        "priority": "medium",
        "dependencies": [
          "110"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:16:39.714Z"
      },
      {
        "id": "112",
        "title": "Integrate Humanization into GrapheneOS Flow",
        "description": "Wire profile/rng into tiktok_poster.py and tiktok_action_engine.py GrapheneOS path, honor --no-humanize.",
        "details": "In tiktok_poster.py: if device=='grapheneos' and not no_humanize: profile, rng = get_profile(phone_name). Pass to action_engine. In handlers: HOME_FEED: if rng.random()<profile.prob_scroll_before_post: human_scroll 1-2x; all taps: tap_with_jitter; sleeps: human_sleep; GALLERY: 0-2 scrolls; etc. Log actions.",
        "testStrategy": "Run with --no-humanize: no extra scrolls/sleeps. With humanize: verify logged jitter/scrolls within profile bounds, video posts successfully.",
        "priority": "high",
        "dependencies": [
          "106",
          "109",
          "111"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:19:44.288Z"
      },
      {
        "id": "113",
        "title": "Add Comprehensive Logging & Validation",
        "description": "Log device/account/seeds/profile/actions. Verify Geelark unchanged, GrapheneOS posts video.",
        "details": "Use logging module: at start log device, phone_name, base_seed, session_seed, profile dict. Per action: logger.info(f'{screen}: {action} params={params}'). Dirs: tiktok_error_logs/, tiktok_flow_analysis/. Final validation: check POST_SUCCESS screen.",
        "testStrategy": "Run full GrapheneOS flow: confirm video uploaded to profile feed. Run Geelark: unchanged success. Inspect logs for seeds/profile/actions.",
        "priority": "medium",
        "dependencies": [
          "112"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:25:41.936Z"
      },
      {
        "id": "114",
        "title": "Create tiktok_id_map.py with semantic element mappings",
        "description": "Implement the ID abstraction layer with ELEMENT_MAP containing multi-signal detection strategies for all required TikTok elements as specified in the PRD.",
        "details": "Create new file `tiktok_id_map.py` with exact ELEMENT_MAP structure from PRD. Include mappings for 'home_create_button', 'camera_gallery_thumb', 'editor_next_button', 'caption_description_field', 'caption_post_button'. Each entry has 'ids' (list of known IDs), 'desc', 'text', 'class', 'position' keys. Use Python dict with string keys and lists/dicts as values. Follow PEP8 standards. Export as: from tiktok_id_map import ELEMENT_MAP.",
        "testStrategy": "Unit test: Validate ELEMENT_MAP structure and keys exist. Assert len(ELEMENT_MAP) == 5. Check each entry has required keys. Manual verification: Print map and confirm matches PRD example.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:37:02.177Z"
      },
      {
        "id": "115",
        "title": "Implement find_element utility function",
        "description": "Develop reusable find_element() function that performs multi-signal detection using strategies from ELEMENT_MAP, with graceful fallback order.",
        "details": "Add to `tiktok_id_map.py` or new `element_finder.py`. Signature: def find_element(elements: List[Dict], semantic_key: str, screen_bounds: Tuple[int, int] = (1080, 2400)) -> Optional[Tuple[int, Dict]]. Logic: 1. Get strategy = ELEMENT_MAP[semantic_key]. 2. Try IDs first (exact match). 3. Fallback to desc/text exact/partial matches. 4. Class + position (divide screen into regions: bottom_left=bottom 30% left 30%, etc.). 5. Return (index, element) or None. Log warnings for each failed strategy. Use fuzzy matching for text (e.g., difflib.get_close_matches).",
        "testStrategy": "Unit tests with mock elements list: Test ID match success, text fallback success, position fallback (mock bounds), all-fail returns None. Integration test: Mock uiautomator elements, assert correct index returned. Coverage >90%.",
        "priority": "high",
        "dependencies": [
          "114"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:37:02.179Z"
      },
      {
        "id": "116",
        "title": "Refactor tiktok_screen_detector.py for multi-signal detection",
        "description": "Replace ID-only detection with find_element() calls for all screens (HOME_FEED, CREATE_MENU, etc.), eliminating single-point failures.",
        "details": "Modify `tiktok_screen_detector.py`: Import ELEMENT_MAP and find_element. For each screen detection (e.g., detect_create_menu()): Get current elements via uiautomator dump. Call find_element(elements, 'home_create_button') etc. Combine multiple signals (e.g., create button + position). Never use single ID check. Implement screen detection as combination of 2+ signals succeeding. Log 'Using fallback strategy X for Y'.",
        "testStrategy": "Integration tests: Mock different uiautomator dumps (ID present/missing, text-only). Assert screen detected correctly in all cases. Fail test if any ID-only logic remains (grep check). Run against real device with current TikTok version.",
        "priority": "high",
        "dependencies": [
          "114",
          "115"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:40:23.984Z"
      },
      {
        "id": "117",
        "title": "Update tiktok_action_engine.py to use find_element utility",
        "description": "Integrate find_element() into action handlers with graceful degradation and detailed logging on failures.",
        "details": "Modify `tiktok_action_engine.py`: Replace hardcoded ID finds with find_element(elements, semantic_key). For actions like click_create(), tap_gallery(): 1. Dump elements. 2. Find via utility. 3. If None, log warning 'ID for X not found; tried text/position' + strategies attempted. 4. Retry with broader bounds if needed. 5. Hard-fail only if all strategies fail after 3 attempts. Add current XML snippet to logs on failure.",
        "testStrategy": "Action tests: Test click/tap actions succeed with ID present, fallback to text/position when ID missing. Mock failures, verify logs contain warnings/version/XML. E2E test full posting flow with simulated ID changes.",
        "priority": "medium",
        "dependencies": [
          "114",
          "115",
          "116"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:45:47.296Z"
      },
      {
        "id": "118",
        "title": "Add TikTok version logging and debugging enhancements",
        "description": "Implement version detection at startup and enhanced failure logging in tiktok_poster.py and related files.",
        "details": "Modify `tiktok_poster.py`: At init/run start, execute `adb shell dumpsys package com.zhiliaoapp.musically | grep versionName`, parse/store as self.tiktok_version. On any detection/action failure: Log '{version}, screen XML snippet, strategies attempted'. Update all log statements to include version. Add to screen_detector and action_engine. Ensure logs are structured (JSON if possible) for easy parsing.",
        "testStrategy": "Unit test version parsing with mock adb output. Integration: Run full flow, simulate failure, grep logs for version/XML/strategies. Verify no crashes on version fetch fail (graceful default). Test across TikTok versions if available.",
        "priority": "medium",
        "dependencies": [
          "116",
          "117"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T07:49:01.459Z"
      },
      {
        "id": "119",
        "title": "Reorganize tiktok_id_map.py with version-aware structure",
        "description": "Restructure the ID mapping to support multiple TikTok versions (Geelark v35, GrapheneOS v43) and implement helper functions get_all_known_ids() and get_ids_for_version().",
        "details": "Replace flat ID structure with TIKTOK_ID_VERSIONS dict as specified in PRD. Implement get_all_known_ids(element) to collect all IDs across versions using set union. Implement get_ids_for_version(version, element) to return version-specific list. Add version detection logic if possible from app metadata, default to '35' for Geelark. Ensure backward compatibility by maintaining all existing IDs.",
        "testStrategy": "Run python -m py_compile tiktok_id_map.py. Test get_all_known_ids('caption_field') returns union of all versions. Test get_ids_for_version('35', 'post_button') returns ['pwo', 'pvz', 'pvl']. Verify get_ids_for_version('43', 'create_button') returns ['mkn'].",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T08:17:17.656Z"
      },
      {
        "id": "120",
        "title": "Add _has_any_id() helper method to tiktok_screen_detector.py",
        "description": "Implement universal helper to check if any element matches known IDs across versions.",
        "details": "Add def _has_any_id(self, elements: List[Dict], id_list: List[str]) -> bool: using set comprehension {el.get('id', '') for el in elements} & set(id_list). Make it a class method in TikTokScreenDetector for reuse in all detection methods.",
        "testStrategy": "Unit test with mock elements containing IDs from different versions. Verify returns True if any match, False otherwise. Syntax check with python -m py_compile.",
        "priority": "high",
        "dependencies": [
          "119"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T08:18:14.698Z"
      },
      {
        "id": "121",
        "title": "Refactor tiktok_screen_detector.py to prioritize text/desc over IDs",
        "description": "Update all key detection methods (_detect_caption_screen, _detect_home_feed, etc.) to use text/desc as primary signals (0.35-0.20 score) and IDs as tertiary boost (0.10 score only).",
        "details": "Follow exact pattern from PRD for _detect_caption_screen(). Implement similar scoring for _detect_home_feed() (\"For You\", \"Following\"), _detect_create_menu() (\"Photo\", \"Text\"), _detect_gallery_picker() (\"Recents\", \"Next\"), _detect_video_editor() (\"Next\", \"Add sound\"). Preserve exact detection order: CAPTION_SCREEN > VIDEO_EDITOR > GALLERY_PICKER > CREATE_MENU > HOME_FEED. Use get_all_known_ids() from task 119 and _has_any_id() from task 120. Remove all position-based detection.",
        "testStrategy": "Verify no position checks via grep -r 'bounds'|'position' tiktok_screen_detector.py. Test scoring: text match >=0.65 passes alone, ID boost only adds 0.10. Syntax check file.",
        "priority": "high",
        "dependencies": [
          "119",
          "120"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T08:30:04.872Z"
      },
      {
        "id": "122",
        "title": "Enhance tiktok_action_engine.py with device-aware coordinates",
        "description": "Add DEVICE_COORDS dict for geelark/grapheneos, device_type init param, and fallback coordinate logic in action handlers.",
        "details": "Implement exact DEVICE_COORDS structure from PRD. In __init__(self, caption='', device_type='geelark'), set self.device_type and self.coords. Update all action methods (tap_create, tap_gallery_thumb, etc.) to try: 1) ANY known ID via get_all_known_ids(), 2) desc match, 3) text match, 4) self.coords['element_fallback']. Use _has_any_id() helper.",
        "testStrategy": "Test init with device_type='grapheneos' sets correct coords. Mock elements: verify ID match first, coord fallback last. Syntax check file. Log fallback usage in tests.",
        "priority": "medium",
        "dependencies": [
          "119",
          "120",
          "121"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T08:30:05.016Z"
      },
      {
        "id": "123",
        "title": "Update tiktok_poster.py to pass device_type to action engine",
        "description": "Modify post() method to instantiate TikTokActionEngine with self.device_type.",
        "details": "Add self.device_type = 'geelark' or detect from platform. In post(): self.action_engine = TikTokActionEngine(caption=caption, device_type=self.device_type). Ensure all action calls use updated engine.",
        "testStrategy": "Syntax check file. Verify action_engine.device_type is set correctly in logs during mock post().",
        "priority": "medium",
        "dependencies": [
          "122"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-26T08:30:05.154Z"
      },
      {
        "id": "124",
        "title": "Full integration testing and validation across devices",
        "description": "Run complete posting workflow on Geelark and GrapheneOS to validate fix without regressions.",
        "details": "Execute full post cycle: home_feed -> create_menu -> gallery_picker -> video_editor -> caption_screen -> post. Capture logs for detection scores and action paths used. Verify text/desc primary detection works, IDs as boost only, device coords as last resort. No position detection.",
        "testStrategy": "Geelark test must pass 100% (preserve existing). GrapheneOS test must pass 100%. Grep all detector files for zero position checks. Review logs: detection scores >=0.65 from text/desc, coord fallbacks only if needed.",
        "priority": "high",
        "dependencies": [
          "119",
          "120",
          "121",
          "122",
          "123"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-26T08:30:05.155Z",
      "taskCount": 20,
      "completedCount": 19,
      "tags": [
        "posting"
      ]
    }
  }
}